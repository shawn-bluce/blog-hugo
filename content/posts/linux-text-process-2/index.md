---
title: "Linux上的简单文本处理"
slug: "linux-text-process-2"
date: "2018-11-19T14:41:00+0000"
lastmod: "2025-01-16T09:36:12+0000"
draft: false
tags:
  - "Linux"
  - "Shell"
visibility: "public"
---
# 0X00 前言

最开始使用Linux的时候一直搞不懂为什么Linux下会有这么多在命令行里操作文本的工具。一度以为这些玩意儿没啥大用，但是随着使用频率与强度的增加才发现这些东西是Linux上非常有魅力的部分。

# 0X01 cat

`cat`命令是最简单的，`cat filename`就是将文件内容以文本的形式输出到命令行。这个命令主要是作为后面组合技的基础，威力到后面cat的作用才能发挥出来。

# 0X02 head

`head`是查看文件的前面部分，默认情况下是前10行，可以使用`-n`参数指定具体的行数。如果你有一个文件巨大无比，比如说几个G，且你只关心前100行，那怎么搞呢。使用`cat`是不可能的了，毕竟你cat一下之后回去睡一觉屏幕都可能还没滚完，何况你还得翻回最上面查看开头的内容。

```sh
    head filename -n 100   # 查看文件的前100行
```

# 0X03 tail

`tail`类似于`head`命令，不过这个是用来查看文件最后的，同样支持使用`-n`参数来指定最后多少行。不过这个命令最多用于查看日志文件。例如你有一个日志文件每秒都在源源不断的写入新内容，此时又想看最新的日志怎么搞呢。`tail`提供了一个`-f`的参数，使用`tail filename -f`就可以输出文件最后的部分且每当新内容写入文件时会追加显示，直到你`Ctrl + C`为止。

这个技能也是后面组合技的基础技能之一，在组合技中更能发挥威力。

# 0X04 grep

查找文件中带有某些特征的行。一个例子：你想找到文件`student_list.txt`中所有带有“小明”的行，那就可以`grep 小明 student_list`。这样就可以看到这个文件中所有包含“小明”的行，并且“小明”二字通常会高亮输出，而不包含的则完全不会输出。

值得注意的一点是`grep`是使用正则表达式进行检索的，所以可以使用正则来匹配内容，所以grep的战斗力很强。比如我们可以使用grep配合正则表达式查找日志文件中所有符合我们要求的内容。

grep还有一种常用的方法，试想这样一个例子：你的一个目录里有大量的文件，你想找到包含`db_password`的行来修改刚刚更换的密码，但是已经忘了在几个地方配置过了，那该咋搞？可以在目录中使用`grep -Rn "db_password" .`来查找。这个命令可以递归的grep当前目录下所有的文件，找到含有`db_password`的行并带有文件名和行号。

grep是组合技中的神技，在grep的加持下组合技可以变得更强大。

# 0X05 ag

上面谈到的`grep -Rn "xxxxx" .`的方法固然好用，但是每次都写一便还是有些麻烦。所以有了这个命令`ag`，它可以完全替换掉这个`grep -Rn "xxx" .`的组合，不仅省时而且得到的输出也更人性化更好看。

> 通常系统不会自带ag命令，包含在一个名为`the_silver_searcher`的包中，如果找不到这个的话可以搜索安装一下。

# 0X06 jq

`jq`是一个用于在命令行中解析输出Json内容并格式化高亮的工具，今天他才帮了我的大忙。jq命令可以将其中的字符串转码为人类可读的类型，并且进行缩进和高亮上色。

如果你有一个名为`test_file.json`的文件，内容为标准的Json，想要查看的话就可以使用`jq . test_file.json`命令来查看格式化并高亮之后的结果。jq工具也可以作为组合技的一部分提升工作效率。

# 0X07 组合技基础：管道

管道就是键盘上的那个小竖线`|`，在Linux中是一个非常重要的概念。简单的理解就是通过管道连接的两串命令可以将前面一串的输出作为后面一串的输入。

具体用法展示就在下面的组合技部分吧，直接在这里说也说不太清楚。

# 0X08 重定向

重定向类似于管道，只是重定向是将输出作为文件或使用文件作为输入。在命令中重定向是使用`< / >`这对大于好和小于号表示的。


    echo "hello,world" > new_file # 将本应该输出的hello,world写入到名为new_file的文件中
    cat < new_file  # 将new_file的内容作为cat的传入参数


## 0X08-1 标准输出、标准错误、标准输入

系统中存在"标准输出/标准输入/标准错误"三个概念，通常标准输出与标准错误都是我们的终端，而标准输入是键盘。
一个命令的输出会分为“标准输出”与“标准错误”。顾名思义，通常的内容使用“标准输出”进行输出，“标准错误”是用来输出错误信息的。
直接使用 `echo "hello,world"` 的时候是将输出内容定向到“标准输出”的，默认是我们的终端。使用命令`ping baidu.com > output`与`ping baidu.com 1> output`是一样的，`1>`代表标准输出，是默认的
使用命令`ping zdlkfjwle > output`会发现还是有内容被打印到了终端上，是因为错误信息使用了“标准错误”来输出，想要重定向标准错误的输出就需要使用`ping lkzsdjf 2> output`了

# 0X09 常用组合技

组合技才是本次的重点，这里介绍几种常用的组合技供大家参考。

追踪日志：
`tail -f nginx_xxx.log | grep timeout`实时追踪在一个持续追加的日志文件，并且只展示其中包含`timeout`的行

追踪多个日志：
`tail -f nginx_success.log nginx_error.log | grep submit`实时追踪多个文件，并展示其中包含`submit`的行

格式化一个Json文件：
`cat old_file.json | jq > new_file.json`将`old_file.json`格式化并生成一个新文件`new_file.json`

找到记不起来ip的服务器：
`history | grep ssh`将你的命令行历史中所有包含ssh的找出来

查找一些进程：
`ps aux | grep java`查找你的java进程

给文件行排序：
`cat student.txt | sort > new_student.txt`给一个名为student.txt的文件排序并生成一个新的

假装模糊搜索：
`find . | grep xxx | grep yyy | grep zzz`你忘了文件在哪，文件名也记不全，可以用这种方式。在母目录执行，相当于找到所有当前目录下的文件中同时包含`xxx`和`yyy`和`zzz`的
